1. Welcome to this video on libraries in Dart. After watching this video, you'll be able to identify and use Dart's common libraries to build robust applications. This video explains how to create a library to reuse and encapsulate data. You'll also be able to import and use libraries to access custom functionalities. Many well known organizations in the world use Flutter cross-platform UI toolkit to build cutting edge products. Dart libraries play a winning role in this process by contributing essential functionalities to streamline coding and development. Next, let's explore Dart's common libraries to access essential functionalities. 


2. First, let's explore Dart core library, which provides essential building blocks for handling basic data types, collections, and utility functions. This library is imported by default. Here is a code snippet to understand a few Dart Core functionalities. This line declares and assigns a value to a string variable named greeting. The next line of code declares and assigns an integer variable. Here, a variable named fruits declares a list of strings, this line specifies a map named scores with string keys and integer values. Next, let's understand the usage of mathematical functions to solve simple calculations and complex algorithms. 


3. The Dart:math library provides you with functionality, such as cosine and sine functions, Pi and e constants, and random number generation. It also provides support for probability based and statistical calculations. This code block will help you understand the Dart:math library. First, import the library, the code calculates and stores the value of angle after which the sine and cosine of the angle are calculated. Next, a random number generator is created, and finally, a random number 0-99 is generated. Another important library is Dart async, which helps you create asynchronous code, including stream and future classes. This library helps you build code that can perform multiple tasks that involve delays without blocking other operations. 


4. Futures are values that are accessible in the future, they're essential for asynchronous operations like fetching online data or carrying out lengthy computations. The await keyword pauses execution until the future returns a value. Streams are a series of asynchronous events that manage data flows from users or servers. You can subscribe to a stream and react to individual events, these lines of code will help you explore Dart async. First, import the library, this line defines an asynchronous function that returns a future value. Next, the await keyword simulates a delay of two seconds. Here, the fetch data function is called, and the result is retrieved after the future is complete. 


5. Next is the Dart convert library, which provides converters for UTF-8 and JSON. This library facilitates communication between APIs by converting Dart objects into JSON format and vice versa. Since APIs rely on JSON for data exchange, the Dart convert library is essential for connecting Dart objects with external systems. This code will help you familiarize yourself with Dart:convert. First, the Dart:convert library will have to be imported, then define a JSON string with two properties, name and age. Next, decode the JSON string into a map. Finally, create a new map and encode it into a JSON string. 


6. Let's now look at the HTTP package, which contains high level classes and functions to simplify HTTP connections. It is used to download or transfer data and interact with rest APIs, these lines of code will help you understand this package better. First, import the package. Next, parse the URL from the string, then a get request is sent to the specified URL, and HTTP response is printed if the response code is 200. Next is the intl package that can resolve a unique and widespread problem. Many apps find it difficult to expand their geographical reach or improve user experience across global markets. The initial package provides localization and internationalization support for apps that need to be adapted to different regions and languages. 


7. Import this package to use in your code, this line creates an object for the current date and time. Next, an object is created to format dates into a particular format, then the formatted data and time are placed in a string. The final package is critical for the manipulation of paths, for files and directories. It helps organize and manage these entities efficiently. The path package provides operations such as splitting, joining, and normalizing to manipulate paths. First, import this package, this line of code combines the directory name and file name to create one file path. Next, create your own library to encapsulate reusable code. 


8. This will boost maintainability and modularity in your projects through the organization of similar functionalities. Having your own library will also allow you to share your code with other members of your organization. The first step is to create a new Dart file and define your library using the library keyword. Then define the functions, classes, and variables you want to include in your library. Your next step after creating a library would be to use it in another file. The import keyword will help you access classes, functions, and variables in your library without duplicating code. Here is how it can be done. 


9. First, import the Math utils library the main function will then access and use the functions defined in your library. In this video, you learned that the Dart core library provides essential building blocks for handling basic data types, collections, and utility functions. The Dart async library is useful for handling tasks that involve delays, such as network request or I/O. The Dart convert library enables JSON handling, allowing applications to communicate with other apps or APIs. The HTTP package contains high level classes and functions for working with data or, RESTful APIs. The intl package provides localization and internationalization support that help apps adapt to different regions and languages. The path package provides operations such as splitting, joining, and normalizing to manipulate file and directory paths, creating your own library, boost maintainability, and modularity in projects. 


10. To create a library file, create a new Dart file, define your library and the functions, classes and variable you want to include in it. Use the import keyword to use a library in another file, access classes, functions, and variables in your library without duplicating code.